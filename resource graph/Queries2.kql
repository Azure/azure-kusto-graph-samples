let tenants=dynamic(["Contoso"]);
NodesLKV(interestingTenants=tenants)

let properties = dynamic(["Age"]);
NodesLKV(interestingProperties=properties)

Nodes(datetime(2024-10-22))

EdgesLKV()

let properties = dynamic(["LocationFilter"]);
Edges(datetime(2024-10-22), interestingProperties=properties)

let tenants=dynamic(["Contoso"]);
let nodeProperties = dynamic(["Age"]);
let edgeProperties = dynamic(["LocationFilter"]);
GraphLKV(interestingTenants=tenants, interestingEdgeProperties=edgeProperties, interestingNodeProperties=nodeProperties)

Graph(now())

//Statistics on resource assignments
let interestingUser = "Alice";
let tenants=dynamic(["Contoso"]);
GraphLKV(interestingTenants=tenants)
| graph-match (resource)<-[authorized_on*1..4]-(group)-[hasMember*1..255]->(user)
    where user.NodeId == interestingUser and user.NodeType == "User" and hasMember.EdgeType == "has_member" and group.NodeType == "Group" and
        authorized_on.EdgeType in ("authorized_on", "contains_resource")
    project Username=user.NodeId, userFQDN=user.FQDN, resourceTenantId=resource.TenantId, resourceType=resource.NodeType, resourceName=resource.NodeId
| summarize Username = take_any(Username), Tenants=dcount(resourceTenantId), ResourceTypes=dcount(resourceType), Resources=dcount(resourceName) by userFQDN

//Check Bob, who has direct and group based access to resources
let interestingUser = "Bob";
let G = GraphLKV();
let groupBasedAccess = view() {
    G
    | graph-match (resource)<-[authorized_on*1..4]-(group)-[hasMember*1..255]->(user)
        where user.NodeId == interestingUser and user.NodeType == "User" and hasMember.EdgeType == "has_member" and group.NodeType == "Group" and
            authorized_on.EdgeType in ("authorized_on", "contains_resource")
        project Username=user.NodeId, userFQDN=user.FQDN, resourceTenantId=resource.TenantId, resourceType=resource.NodeType, resourceName=resource.NodeId
};
let directAccess = view() {
    G
    | graph-match (resource)<-[authorized_on*1..4]-(user)
        where user.NodeId == interestingUser and user.NodeType == "User" and
            authorized_on.EdgeType in ("authorized_on", "contains_resource")
        project Username=user.NodeId, userFQDN=user.FQDN, resourceTenantId=resource.TenantId, resourceType=resource.NodeType, resourceName=resource.NodeId
};
union withsource=Assignment groupBasedAccess, directAccess
| summarize Username = take_any(Username), Tenants=dcount(resourceTenantId), ResourceTypes=dcount(resourceType), Resources=dcount(resourceName) by userFQDN, Assignment

//Check Bob, who has direct and group based access to resources
let interestingUsers = dynamic(["Bob", "Alice"]);
let G = GraphLKV();
let groupBasedAccess = view() {
    G
    | graph-match (resource)<-[authorized_on*1..4]-(group)-[hasMember*1..255]->(user)
        where user.NodeId in (interestingUsers) and user.NodeType == "User" and hasMember.EdgeType == "has_member" and group.NodeType == "Group" and
            authorized_on.EdgeType in ("authorized_on", "contains_resource")
        project Username=user.NodeId, userFQDN=user.FQDN, resourceTenantId=resource.TenantId, resourceType=resource.NodeType, resourceName=resource.NodeId
};
let directAccess = view() {
    G
    | graph-match (resource)<-[authorized_on*1..4]-(user)
        where user.NodeId in (interestingUsers) and user.NodeType == "User" and
            authorized_on.EdgeType in ("authorized_on", "contains_resource")
        project Username=user.NodeId, userFQDN=user.FQDN, resourceTenantId=resource.TenantId, resourceType=resource.NodeType, resourceName=resource.NodeId
};
union withsource=Assignment groupBasedAccess, directAccess
| summarize Username = take_any(Username), Tenants=dcount(resourceTenantId), ResourceTypes=dcount(resourceType), Resources=dcount(resourceName) by userFQDN, Assignment

//Provide all permissions of a user on VMs
let interestingUsers = dynamic(["Alice", "Bob"]);
let interestingResourceTypes = dynamic(["VirtualMachine"]);
let tenants=dynamic(["Contoso"]);
let G = GraphLKV(interestingTenants=tenants);
let groupBasedAccess = view() {
    G
    | graph-match (resource)<-[authorized_on*1..4]-(group)-[hasMember*1..255]->(user)
        where user.NodeId in (interestingUsers) and user.NodeType == "User" and hasMember.EdgeType == "has_member" and group.NodeType == "Group" and
            authorized_on.EdgeType in ("authorized_on", "contains_resource") and resource.NodeType in (interestingResourceTypes)
        project Username=user.NodeId, userFQDN=user.FQDN, resourceTenantId=resource.TenantId, resourceType=resource.NodeType, resourceName=resource.NodeId, AuthorizationLabels=authorized_on.Labels
};
let directAccess = view() {
    G
    | graph-match (resource)<-[authorized_on*1..4]-(user)
        where user.NodeId in (interestingUsers) and user.NodeType == "User" and
            authorized_on.EdgeType in ("authorized_on", "contains_resource")
        project Username=user.NodeId, userFQDN=user.FQDN, resourceTenantId=resource.TenantId, resourceType=resource.NodeType, resourceName=resource.NodeId, AuthorizationLabels=authorized_on.Labels
};
union withsource=Assignment groupBasedAccess, directAccess
| mv-apply AuthLabel=AuthorizationLabels on (
    where array_length(AuthLabel) > 0
)
| mv-expand AuthLabel to typeof(string)
| summarize Permissions=make_set(AuthLabel) by userFQDN, resourceTenantId, resourceType, resourceName


//Blast radius... what happens if a resource is not working? Which users are impacted?
let interestingResourceTypes = dynamic(["VirtualMachine"]);
let interestingResources = dynamic(["VM1"]);
let tenants=dynamic(["Contoso"]);
GraphLKV(interestingTenants=tenants)
| graph-match cycles=none (resource)-[e*1..255]-(user)
    where resource.NodeId in (interestingResources) and resource.NodeType in (interestingResourceTypes) and user.NodeType == "User"
    project Username=user.NodeId, Tenant=user.TenantId, userFQDN=user.FQDN
| distinct userFQDN, Username, Tenant